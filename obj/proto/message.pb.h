// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef PROTOBUF_INCLUDED_message_2eproto
#define PROTOBUF_INCLUDED_message_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_message_2eproto 

namespace protobuf_message_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_message_2eproto
class MessageProto;
class MessageProtoDefaultTypeInternal;
extern MessageProtoDefaultTypeInternal _MessageProto_default_instance_;
namespace google {
namespace protobuf {
template<> ::MessageProto* Arena::CreateMaybeMessage<::MessageProto>(Arena*);
}  // namespace protobuf
}  // namespace google

enum MessageProto_MessageType {
  MessageProto_MessageType_EMPTY = 0,
  MessageProto_MessageType_TXN_PROTO = 1,
  MessageProto_MessageType_TXN_BATCH = 2,
  MessageProto_MessageType_READ_RESULT = 3,
  MessageProto_MessageType_LINK_CHANNEL = 4,
  MessageProto_MessageType_UNLINK_CHANNEL = 5,
  MessageProto_MessageType_TXN_PTR = 6,
  MessageProto_MessageType_MESSAGE_PTR = 7
};
bool MessageProto_MessageType_IsValid(int value);
const MessageProto_MessageType MessageProto_MessageType_MessageType_MIN = MessageProto_MessageType_EMPTY;
const MessageProto_MessageType MessageProto_MessageType_MessageType_MAX = MessageProto_MessageType_MESSAGE_PTR;
const int MessageProto_MessageType_MessageType_ARRAYSIZE = MessageProto_MessageType_MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageProto_MessageType_descriptor();
inline const ::std::string& MessageProto_MessageType_Name(MessageProto_MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageProto_MessageType_descriptor(), value);
}
inline bool MessageProto_MessageType_Parse(
    const ::std::string& name, MessageProto_MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageProto_MessageType>(
    MessageProto_MessageType_descriptor(), name, value);
}
// ===================================================================

class MessageProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MessageProto) */ {
 public:
  MessageProto();
  virtual ~MessageProto();

  MessageProto(const MessageProto& from);

  inline MessageProto& operator=(const MessageProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageProto(MessageProto&& from) noexcept
    : MessageProto() {
    *this = ::std::move(from);
  }

  inline MessageProto& operator=(MessageProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageProto* internal_default_instance() {
    return reinterpret_cast<const MessageProto*>(
               &_MessageProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(MessageProto* other);
  friend void swap(MessageProto& a, MessageProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageProto* New() const final {
    return CreateMaybeMessage<MessageProto>(NULL);
  }

  MessageProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageProto& from);
  void MergeFrom(const MessageProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MessageProto_MessageType MessageType;
  static const MessageType EMPTY =
    MessageProto_MessageType_EMPTY;
  static const MessageType TXN_PROTO =
    MessageProto_MessageType_TXN_PROTO;
  static const MessageType TXN_BATCH =
    MessageProto_MessageType_TXN_BATCH;
  static const MessageType READ_RESULT =
    MessageProto_MessageType_READ_RESULT;
  static const MessageType LINK_CHANNEL =
    MessageProto_MessageType_LINK_CHANNEL;
  static const MessageType UNLINK_CHANNEL =
    MessageProto_MessageType_UNLINK_CHANNEL;
  static const MessageType TXN_PTR =
    MessageProto_MessageType_TXN_PTR;
  static const MessageType MESSAGE_PTR =
    MessageProto_MessageType_MESSAGE_PTR;
  static inline bool MessageType_IsValid(int value) {
    return MessageProto_MessageType_IsValid(value);
  }
  static const MessageType MessageType_MIN =
    MessageProto_MessageType_MessageType_MIN;
  static const MessageType MessageType_MAX =
    MessageProto_MessageType_MessageType_MAX;
  static const int MessageType_ARRAYSIZE =
    MessageProto_MessageType_MessageType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MessageType_descriptor() {
    return MessageProto_MessageType_descriptor();
  }
  static inline const ::std::string& MessageType_Name(MessageType value) {
    return MessageProto_MessageType_Name(value);
  }
  static inline bool MessageType_Parse(const ::std::string& name,
      MessageType* value) {
    return MessageProto_MessageType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated bytes data = 11;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 11;
  const ::std::string& data(int index) const;
  ::std::string* mutable_data(int index);
  void set_data(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_data(int index, ::std::string&& value);
  #endif
  void set_data(int index, const char* value);
  void set_data(int index, const void* value, size_t size);
  ::std::string* add_data();
  void add_data(const ::std::string& value);
  #if LANG_CXX11
  void add_data(::std::string&& value);
  #endif
  void add_data(const char* value);
  void add_data(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& data() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_data();

  // repeated int64 data_ptr = 12;
  int data_ptr_size() const;
  void clear_data_ptr();
  static const int kDataPtrFieldNumber = 12;
  ::google::protobuf::int64 data_ptr(int index) const;
  void set_data_ptr(int index, ::google::protobuf::int64 value);
  void add_data_ptr(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      data_ptr() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_data_ptr();

  // repeated bytes keys = 31;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 31;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const void* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // repeated bytes values = 32;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 32;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const void* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // required string destination_channel = 2;
  bool has_destination_channel() const;
  void clear_destination_channel();
  static const int kDestinationChannelFieldNumber = 2;
  const ::std::string& destination_channel() const;
  void set_destination_channel(const ::std::string& value);
  #if LANG_CXX11
  void set_destination_channel(::std::string&& value);
  #endif
  void set_destination_channel(const char* value);
  void set_destination_channel(const char* value, size_t size);
  ::std::string* mutable_destination_channel();
  ::std::string* release_destination_channel();
  void set_allocated_destination_channel(::std::string* destination_channel);

  // optional string main_channel = 1001;
  bool has_main_channel() const;
  void clear_main_channel();
  static const int kMainChannelFieldNumber = 1001;
  const ::std::string& main_channel() const;
  void set_main_channel(const ::std::string& value);
  #if LANG_CXX11
  void set_main_channel(::std::string&& value);
  #endif
  void set_main_channel(const char* value);
  void set_main_channel(const char* value, size_t size);
  ::std::string* mutable_main_channel();
  ::std::string* release_main_channel();
  void set_allocated_main_channel(::std::string* main_channel);

  // optional string channel_request = 1002;
  bool has_channel_request() const;
  void clear_channel_request();
  static const int kChannelRequestFieldNumber = 1002;
  const ::std::string& channel_request() const;
  void set_channel_request(const ::std::string& value);
  #if LANG_CXX11
  void set_channel_request(::std::string&& value);
  #endif
  void set_channel_request(const char* value);
  void set_channel_request(const char* value, size_t size);
  ::std::string* mutable_channel_request();
  ::std::string* release_channel_request();
  void set_allocated_channel_request(::std::string* channel_request);

  // required int32 destination_node = 1;
  bool has_destination_node() const;
  void clear_destination_node();
  static const int kDestinationNodeFieldNumber = 1;
  ::google::protobuf::int32 destination_node() const;
  void set_destination_node(::google::protobuf::int32 value);

  // optional int32 source_node = 3;
  bool has_source_node() const;
  void clear_source_node();
  static const int kSourceNodeFieldNumber = 3;
  ::google::protobuf::int32 source_node() const;
  void set_source_node(::google::protobuf::int32 value);

  // optional int32 source_channel = 4;
  bool has_source_channel() const;
  void clear_source_channel();
  static const int kSourceChannelFieldNumber = 4;
  ::google::protobuf::int32 source_channel() const;
  void set_source_channel(::google::protobuf::int32 value);

  // required .MessageProto.MessageType type = 9;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 9;
  ::MessageProto_MessageType type() const;
  void set_type(::MessageProto_MessageType value);

  // optional int64 batch_number = 21;
  bool has_batch_number() const;
  void clear_batch_number();
  static const int kBatchNumberFieldNumber = 21;
  ::google::protobuf::int64 batch_number() const;
  void set_batch_number(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:MessageProto)
 private:
  void set_has_destination_node();
  void clear_has_destination_node();
  void set_has_destination_channel();
  void clear_has_destination_channel();
  void set_has_source_node();
  void clear_has_source_node();
  void set_has_source_channel();
  void clear_has_source_channel();
  void set_has_type();
  void clear_has_type();
  void set_has_batch_number();
  void clear_has_batch_number();
  void set_has_main_channel();
  void clear_has_main_channel();
  void set_has_channel_request();
  void clear_has_channel_request();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> data_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > data_ptr_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  ::google::protobuf::internal::ArenaStringPtr destination_channel_;
  ::google::protobuf::internal::ArenaStringPtr main_channel_;
  ::google::protobuf::internal::ArenaStringPtr channel_request_;
  ::google::protobuf::int32 destination_node_;
  ::google::protobuf::int32 source_node_;
  ::google::protobuf::int32 source_channel_;
  int type_;
  ::google::protobuf::int64 batch_number_;
  friend struct ::protobuf_message_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// MessageProto

// required int32 destination_node = 1;
inline bool MessageProto::has_destination_node() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageProto::set_has_destination_node() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageProto::clear_has_destination_node() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageProto::clear_destination_node() {
  destination_node_ = 0;
  clear_has_destination_node();
}
inline ::google::protobuf::int32 MessageProto::destination_node() const {
  // @@protoc_insertion_point(field_get:MessageProto.destination_node)
  return destination_node_;
}
inline void MessageProto::set_destination_node(::google::protobuf::int32 value) {
  set_has_destination_node();
  destination_node_ = value;
  // @@protoc_insertion_point(field_set:MessageProto.destination_node)
}

// required string destination_channel = 2;
inline bool MessageProto::has_destination_channel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageProto::set_has_destination_channel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageProto::clear_has_destination_channel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageProto::clear_destination_channel() {
  destination_channel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_destination_channel();
}
inline const ::std::string& MessageProto::destination_channel() const {
  // @@protoc_insertion_point(field_get:MessageProto.destination_channel)
  return destination_channel_.GetNoArena();
}
inline void MessageProto::set_destination_channel(const ::std::string& value) {
  set_has_destination_channel();
  destination_channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MessageProto.destination_channel)
}
#if LANG_CXX11
inline void MessageProto::set_destination_channel(::std::string&& value) {
  set_has_destination_channel();
  destination_channel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MessageProto.destination_channel)
}
#endif
inline void MessageProto::set_destination_channel(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_destination_channel();
  destination_channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MessageProto.destination_channel)
}
inline void MessageProto::set_destination_channel(const char* value, size_t size) {
  set_has_destination_channel();
  destination_channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MessageProto.destination_channel)
}
inline ::std::string* MessageProto::mutable_destination_channel() {
  set_has_destination_channel();
  // @@protoc_insertion_point(field_mutable:MessageProto.destination_channel)
  return destination_channel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageProto::release_destination_channel() {
  // @@protoc_insertion_point(field_release:MessageProto.destination_channel)
  if (!has_destination_channel()) {
    return NULL;
  }
  clear_has_destination_channel();
  return destination_channel_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageProto::set_allocated_destination_channel(::std::string* destination_channel) {
  if (destination_channel != NULL) {
    set_has_destination_channel();
  } else {
    clear_has_destination_channel();
  }
  destination_channel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), destination_channel);
  // @@protoc_insertion_point(field_set_allocated:MessageProto.destination_channel)
}

// optional int32 source_node = 3;
inline bool MessageProto::has_source_node() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageProto::set_has_source_node() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageProto::clear_has_source_node() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageProto::clear_source_node() {
  source_node_ = 0;
  clear_has_source_node();
}
inline ::google::protobuf::int32 MessageProto::source_node() const {
  // @@protoc_insertion_point(field_get:MessageProto.source_node)
  return source_node_;
}
inline void MessageProto::set_source_node(::google::protobuf::int32 value) {
  set_has_source_node();
  source_node_ = value;
  // @@protoc_insertion_point(field_set:MessageProto.source_node)
}

// optional int32 source_channel = 4;
inline bool MessageProto::has_source_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageProto::set_has_source_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageProto::clear_has_source_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageProto::clear_source_channel() {
  source_channel_ = 0;
  clear_has_source_channel();
}
inline ::google::protobuf::int32 MessageProto::source_channel() const {
  // @@protoc_insertion_point(field_get:MessageProto.source_channel)
  return source_channel_;
}
inline void MessageProto::set_source_channel(::google::protobuf::int32 value) {
  set_has_source_channel();
  source_channel_ = value;
  // @@protoc_insertion_point(field_set:MessageProto.source_channel)
}

// required .MessageProto.MessageType type = 9;
inline bool MessageProto::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MessageProto::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MessageProto::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MessageProto::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::MessageProto_MessageType MessageProto::type() const {
  // @@protoc_insertion_point(field_get:MessageProto.type)
  return static_cast< ::MessageProto_MessageType >(type_);
}
inline void MessageProto::set_type(::MessageProto_MessageType value) {
  assert(::MessageProto_MessageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:MessageProto.type)
}

// repeated bytes data = 11;
inline int MessageProto::data_size() const {
  return data_.size();
}
inline void MessageProto::clear_data() {
  data_.Clear();
}
inline const ::std::string& MessageProto::data(int index) const {
  // @@protoc_insertion_point(field_get:MessageProto.data)
  return data_.Get(index);
}
inline ::std::string* MessageProto::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:MessageProto.data)
  return data_.Mutable(index);
}
inline void MessageProto::set_data(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MessageProto.data)
  data_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MessageProto::set_data(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:MessageProto.data)
  data_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MessageProto::set_data(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  data_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MessageProto.data)
}
inline void MessageProto::set_data(int index, const void* value, size_t size) {
  data_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MessageProto.data)
}
inline ::std::string* MessageProto::add_data() {
  // @@protoc_insertion_point(field_add_mutable:MessageProto.data)
  return data_.Add();
}
inline void MessageProto::add_data(const ::std::string& value) {
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MessageProto.data)
}
#if LANG_CXX11
inline void MessageProto::add_data(::std::string&& value) {
  data_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MessageProto.data)
}
#endif
inline void MessageProto::add_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  data_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MessageProto.data)
}
inline void MessageProto::add_data(const void* value, size_t size) {
  data_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MessageProto.data)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MessageProto::data() const {
  // @@protoc_insertion_point(field_list:MessageProto.data)
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MessageProto::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:MessageProto.data)
  return &data_;
}

// repeated int64 data_ptr = 12;
inline int MessageProto::data_ptr_size() const {
  return data_ptr_.size();
}
inline void MessageProto::clear_data_ptr() {
  data_ptr_.Clear();
}
inline ::google::protobuf::int64 MessageProto::data_ptr(int index) const {
  // @@protoc_insertion_point(field_get:MessageProto.data_ptr)
  return data_ptr_.Get(index);
}
inline void MessageProto::set_data_ptr(int index, ::google::protobuf::int64 value) {
  data_ptr_.Set(index, value);
  // @@protoc_insertion_point(field_set:MessageProto.data_ptr)
}
inline void MessageProto::add_data_ptr(::google::protobuf::int64 value) {
  data_ptr_.Add(value);
  // @@protoc_insertion_point(field_add:MessageProto.data_ptr)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
MessageProto::data_ptr() const {
  // @@protoc_insertion_point(field_list:MessageProto.data_ptr)
  return data_ptr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
MessageProto::mutable_data_ptr() {
  // @@protoc_insertion_point(field_mutable_list:MessageProto.data_ptr)
  return &data_ptr_;
}

// optional int64 batch_number = 21;
inline bool MessageProto::has_batch_number() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MessageProto::set_has_batch_number() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MessageProto::clear_has_batch_number() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MessageProto::clear_batch_number() {
  batch_number_ = GOOGLE_LONGLONG(0);
  clear_has_batch_number();
}
inline ::google::protobuf::int64 MessageProto::batch_number() const {
  // @@protoc_insertion_point(field_get:MessageProto.batch_number)
  return batch_number_;
}
inline void MessageProto::set_batch_number(::google::protobuf::int64 value) {
  set_has_batch_number();
  batch_number_ = value;
  // @@protoc_insertion_point(field_set:MessageProto.batch_number)
}

// repeated bytes keys = 31;
inline int MessageProto::keys_size() const {
  return keys_.size();
}
inline void MessageProto::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& MessageProto::keys(int index) const {
  // @@protoc_insertion_point(field_get:MessageProto.keys)
  return keys_.Get(index);
}
inline ::std::string* MessageProto::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:MessageProto.keys)
  return keys_.Mutable(index);
}
inline void MessageProto::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MessageProto.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MessageProto::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:MessageProto.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MessageProto::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MessageProto.keys)
}
inline void MessageProto::set_keys(int index, const void* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MessageProto.keys)
}
inline ::std::string* MessageProto::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:MessageProto.keys)
  return keys_.Add();
}
inline void MessageProto::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MessageProto.keys)
}
#if LANG_CXX11
inline void MessageProto::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MessageProto.keys)
}
#endif
inline void MessageProto::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MessageProto.keys)
}
inline void MessageProto::add_keys(const void* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MessageProto.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MessageProto::keys() const {
  // @@protoc_insertion_point(field_list:MessageProto.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MessageProto::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:MessageProto.keys)
  return &keys_;
}

// repeated bytes values = 32;
inline int MessageProto::values_size() const {
  return values_.size();
}
inline void MessageProto::clear_values() {
  values_.Clear();
}
inline const ::std::string& MessageProto::values(int index) const {
  // @@protoc_insertion_point(field_get:MessageProto.values)
  return values_.Get(index);
}
inline ::std::string* MessageProto::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:MessageProto.values)
  return values_.Mutable(index);
}
inline void MessageProto::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MessageProto.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MessageProto::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:MessageProto.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MessageProto::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MessageProto.values)
}
inline void MessageProto::set_values(int index, const void* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MessageProto.values)
}
inline ::std::string* MessageProto::add_values() {
  // @@protoc_insertion_point(field_add_mutable:MessageProto.values)
  return values_.Add();
}
inline void MessageProto::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MessageProto.values)
}
#if LANG_CXX11
inline void MessageProto::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MessageProto.values)
}
#endif
inline void MessageProto::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MessageProto.values)
}
inline void MessageProto::add_values(const void* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MessageProto.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MessageProto::values() const {
  // @@protoc_insertion_point(field_list:MessageProto.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MessageProto::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:MessageProto.values)
  return &values_;
}

// optional string main_channel = 1001;
inline bool MessageProto::has_main_channel() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageProto::set_has_main_channel() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageProto::clear_has_main_channel() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageProto::clear_main_channel() {
  main_channel_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_main_channel();
}
inline const ::std::string& MessageProto::main_channel() const {
  // @@protoc_insertion_point(field_get:MessageProto.main_channel)
  return main_channel_.GetNoArena();
}
inline void MessageProto::set_main_channel(const ::std::string& value) {
  set_has_main_channel();
  main_channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MessageProto.main_channel)
}
#if LANG_CXX11
inline void MessageProto::set_main_channel(::std::string&& value) {
  set_has_main_channel();
  main_channel_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MessageProto.main_channel)
}
#endif
inline void MessageProto::set_main_channel(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_main_channel();
  main_channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MessageProto.main_channel)
}
inline void MessageProto::set_main_channel(const char* value, size_t size) {
  set_has_main_channel();
  main_channel_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MessageProto.main_channel)
}
inline ::std::string* MessageProto::mutable_main_channel() {
  set_has_main_channel();
  // @@protoc_insertion_point(field_mutable:MessageProto.main_channel)
  return main_channel_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageProto::release_main_channel() {
  // @@protoc_insertion_point(field_release:MessageProto.main_channel)
  if (!has_main_channel()) {
    return NULL;
  }
  clear_has_main_channel();
  return main_channel_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageProto::set_allocated_main_channel(::std::string* main_channel) {
  if (main_channel != NULL) {
    set_has_main_channel();
  } else {
    clear_has_main_channel();
  }
  main_channel_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), main_channel);
  // @@protoc_insertion_point(field_set_allocated:MessageProto.main_channel)
}

// optional string channel_request = 1002;
inline bool MessageProto::has_channel_request() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageProto::set_has_channel_request() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageProto::clear_has_channel_request() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageProto::clear_channel_request() {
  channel_request_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_channel_request();
}
inline const ::std::string& MessageProto::channel_request() const {
  // @@protoc_insertion_point(field_get:MessageProto.channel_request)
  return channel_request_.GetNoArena();
}
inline void MessageProto::set_channel_request(const ::std::string& value) {
  set_has_channel_request();
  channel_request_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MessageProto.channel_request)
}
#if LANG_CXX11
inline void MessageProto::set_channel_request(::std::string&& value) {
  set_has_channel_request();
  channel_request_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MessageProto.channel_request)
}
#endif
inline void MessageProto::set_channel_request(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_channel_request();
  channel_request_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MessageProto.channel_request)
}
inline void MessageProto::set_channel_request(const char* value, size_t size) {
  set_has_channel_request();
  channel_request_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MessageProto.channel_request)
}
inline ::std::string* MessageProto::mutable_channel_request() {
  set_has_channel_request();
  // @@protoc_insertion_point(field_mutable:MessageProto.channel_request)
  return channel_request_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MessageProto::release_channel_request() {
  // @@protoc_insertion_point(field_release:MessageProto.channel_request)
  if (!has_channel_request()) {
    return NULL;
  }
  clear_has_channel_request();
  return channel_request_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MessageProto::set_allocated_channel_request(::std::string* channel_request) {
  if (channel_request != NULL) {
    set_has_channel_request();
  } else {
    clear_has_channel_request();
  }
  channel_request_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), channel_request);
  // @@protoc_insertion_point(field_set_allocated:MessageProto.channel_request)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::MessageProto_MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MessageProto_MessageType>() {
  return ::MessageProto_MessageType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_message_2eproto
